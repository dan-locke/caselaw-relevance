{{ define "title" }}
	{{ .Id}} - {{ .CaseTitle }}
{{ end }}

{{ define "content" }}
<div class="container" id="vm">
	<div class="row justify-content-start align-items-start">
		<div class="col-5">
			<div class="card" style="max-height: 90vh;">
				<div class="card-header">
					<ul id="card-nav" class="nav nav-tabs card-header-tabs" role="tablist">
						<li class="nav-item">
							<a id="topic-tab" class="nav-link active" data-toggle="tab" aria-controls="topic" aria-expanded="true" href="#topic">Topic {{ .Id }}
							</a>
						</li>
						<li class="nav-item">
							<a id="tag-tab" class="nav-link" data-toggle="tab" aria-controls="tags" href="#tags">Tags</a>
						</li>
						<li class="nav-item">
							<a id="docs-tab" class="nav-link" data-toggle="tab" aria-controls="docs" href="#docs">Docs</a>
						</li>
						<li class="nav-item">
							<a id="search-tab" class="nav-link" data-toggle="tab" aria-controls="srch" href="#srch">Search</a>
						</li>
					</ul>
				</div>
				<div id="card-nav-content" class="card-body tab-content" style=" overflow: scroll;">
					<div role="tabpanel" class="tab-pane fade show active" id="topic" aria-labelledby="topic-tab">
						<h6 class="card-subtitle mb-2 text-muted">{{ .CaseTitle }} | {{ .CaseId }}</h6>
						<p class="card-text">
							<ul class="list-group border-right-0 border-left-0 ">
								<li class="list-group-item border-right-0 border-left-0 border-top-0">
									{{ range $i, $case := .CitedCase }}
									{{ if $i }}
									|
									{{ end }}
									{{ $case }}
									{{ end }}
								</li>
								<li class="list-group-item border-right-0 border-left-0">
									{{ range $i, $id := .CitedId }}
									{{ if $i }}
									|
									{{ end }}
									{{ $id }}
									{{ end }}
								</li>
								<li class="list-group-item border-right-0 border-left-0">
									{{ range $i, $keyword := .RelevantKeywords }}
									{{ if $i }}
									|
									{{ end }}
									{{ $keyword }}
									{{ end }}
								</li>
								<li class="list-group-item border-right-0 border-left-0">{{ .CitingSentence }}</li>
								<li class="list-group-item border-right-0 border-left-0 border-bottom-0">{{ .CitingParagraph }}</li>
							</ul>
						</p>
					</div>
					<div role="tabpanel" class="tab-pane fade" id="tags" aria-labelledby="tag-tab">
						<h6 class="card-subtitle mb-2 text-muted">Current tags</h6>
						<p class="card-text" id="seltxt">
							<ul class="list-group border-right-0 border-left-0">
								<li class="list-group-item  border-right-0 border-left-0" v-for="tag in tags">
									[[ tag.start ]] - [[ tag.end ]] | [[ tag.tag_id ]] | [[ tag.text ]]
									<button type="button" class="btn btn-sm btn-warning" v-on:click="deleteTag(tag.tag_id)">Delete</button>
								</li>
							</ul>
						</p>
						<button type="button" class="btn btn-primary" v-on:click="getSelection">Tag</button>
					</div>
					<div role="tabpanel" class="tab-pane fade" id="docs" aria-labelledby="docs-tab">
						<h6 class="card-subtitle mb-2 text-muted">Documents</h6>
						<p class="card-text" id="seltxt">
							<ul class="list-group border-right-0 border-left-0">
								<li class="list-group-item  border-right-0 border-left-0" v-for="(doc, i) in hits">
									<a href="#" v-on:click="changeDoc(i)">[[ doc.case_name ]]</a>
									<span v-if="doc.relevance === '' || doc.relevance === undefined">
										<span class="badge badge-danger">Not assessed</span>
									</span>
									<span v-else>
										<span v-if="doc.stored">
											<span class="badge badge-success">Assessed</span>
										</span>
										<span v-else>
											<span class="badge badge-warning">Assessed</span>
										</span>
									</span>
								</li>
							</ul>
						</p>
					</div>
					<div role="tabpanel" class="tab-pane fade" id="srch" aria-labelledby="srch-tab">
						<h6 class="card-subtitle mb-2 text-muted">Documents</h6>
						<p class="card-text">
							Search for further results. These will be added to the list of current documents that you are evaluating. A maximum of 20 results for each search are returned.
							<br>
							<form action="#" class="form-inline my-2 my-lg-0">
								<input class="form-control mr-sm-2" type="text" placeholder="Search" id="search-input" v-model="query">
								<button class="btn btn-outline-success my-2 my-sm-0" type="submit" v-on:click="searchTopic">Search</button>
							</form>
							<br>
							<span v-if="queries">
								<ul class="list-group border-right-0 border-left-0">
									<li class="list-group-item  border-right-0 border-left-0" v-for="q in queries">
										[[ q ]]
									</li>
								</ul>
							</span>
						</p>
					</div>
				</div>
				<div class="card-footer">
					<button class="btn btn-primary" v-on:click="submit">Submit all</button>
				</div>
			</div>
		</div>
		<div class="col-7">
			<div class="card" style="max-height: 90vh;">
				<div class="card-header">[[ getCurrentDoc().case_name ]] | [[ getCurrentDoc().id ]]
					<span v-if="getCurrentDoc().relevance === '' || getCurrentDoc().relevance === undefined">
						<span class="badge badge-danger">Not assessed</span>
					</span>
					<span v-else>
						<span v-if="getCurrentDoc().stored">
							<span class="badge badge-success">Assessed</span>
						</span>
						<span v-else>
							<span class="badge badge-warning">Assessed</span>
						</span>
					</span>
				</div>
				<div class="card-body" style="overflow: scroll;">
					<p class="card-text">
						<p v-html="getCurrentDocHtml()" id="j-txt"></p>
					</p>
				</div>
				<div class="card-footer">
					<div class="row">
						<div class="col">
							<button class="btn btn-secondary" v-on:click="prevDoc">Previous</button>
							<button class="btn btn-secondary" v-on:click="nextDoc">Next</button>
						</div>
						<div class="form-inline">
							<label class="mr-sm-2" for="rl-sel">Relevance</label>
							<select class="custom-select mb-2 mr-sm-2 mb-sm-0" v-model="getCurrentDoc().relevance" id="rl-sel">
								<option v-for="l in rl">[[ l ]]</option>
							</select>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>
{{ end }}

{{ define "js" }}
<script type="text/javascript">
	var topicId = {{ .Id }};
	var relevanceLevels = ['not relevant', 'background', 'explanatory', 'on point'];

	var vm = new Vue({
		el: '#vm',
		delimiters : ['[[', ']]'],
		data: {
			currentDoc: 0,
			prevDoc: 0,
			doc: {
				id: undefined,
				case_name: undefined,
				date_filed: undefined,
				html: undefined,
			},
			hits: [{
				id: undefined,
				case_name: undefined,
				assessed: undefined,
				stored: undefined,
			}],
			tags: [],
			rl: relevanceLevels,
			queries: [],
			query: "",
		},
		computed: {
				numHits: function() {
					return this.hits.length;
				}
		},

		methods: {

			addIds: function() {
				var id = 0;
				var e = document.getElementById("j-txt").getElementsByTagName("*");
				for (var i = 0; i < e.length; i++) {
					e[i].id = "j-"+id;
					id++;
				}
			},

			getTags: function() {
				var self = this
				var xhr = new XMLHttpRequest();
				xhr.open('GET', '/tags/' + topicId + '/' + this.hits[this.currentDoc].id,  true);
				xhr.send();
				// console.log(xhr);
				xhr.onreadystatechange = function () {
					// console.log(xhr.readyState, xhr.status);
					if (xhr.readyState === 4 && xhr.status === 200) {
						var sres = JSON.parse(xhr.responseText);
						self.tags = sres
					} else if (xhr.readyState === 4 && xhr.status !== 200) {
						window.alert('Something went wrong getting tag data!')
					}
				};
			},

			getDoc: function() {
				// $.get('/tdata/' + topicId + '/' + this.hits[this.currentDoc].id,
				// function (response, status) {
				// 	this.doc = response
				// }.bind(this), "json");
				// Stores to disk compared with above...
				var xhr = new XMLHttpRequest();
				xhr.open('GET', '/tdata/' + topicId + '/' + this.hits[this.currentDoc].id,  true);
				xhr.send();
				// console.log(xhr);
				xhr.onreadystatechange = function () {
					// console.log(xhr.readyState, xhr.status);
					if (xhr.readyState === 4 && xhr.status === 200) {
						var res = JSON.parse(xhr.responseText);
						this.doc = res;
						// update relevance status to check from db...
						if (!this.hits[this.currentDoc].stored) {
							this.hits[this.currentDoc].relevance = res.relevance;
						}
						this.$nextTick(function() {
							this.addIds();
							this.getTags();
						});
					} else if (xhr.readyState === 4 && xhr.status !== 200) {
						window.alert('Something went wrong getting tag data!')
					}
				}.bind(this);
			},

			getCurrentDocHtml: function() {
				return this.doc.html
			},

			getCurrentDoc : function() {
				return this.hits[this.currentDoc];
			},

			changeDoc: function(i) {
				this.prevDoc = this.currentDoc
				this.currentDoc = i;
			},

			nextDoc: function(event) {
				this.prevDoc = this.currentDoc
				this.currentDoc++;
				if (this.currentDoc >= this.numHits) {
					this.currentDoc = 0;
				}
			},

			prevDoc: function(event) {
				this.prevDoc = this.currentDoc
				this.currentDoc--;
				if (this.currentDoc < 0) {
					this.currentDoc = this.numHits;
				}
			},

			assess: function() {
				var h = this.hits[this.prevDoc];
				if (h.relevance != undefined) {
					var xhr = new XMLHttpRequest();
					xhr.open('POST', '/assess');
					xhr.setRequestHeader('Content-Type', 'application/json');
					xhr.send(JSON.stringify({'id': topicId, 'assessments':
						[{'id': parseInt(h.id), 'relevance': h.relevance}]}));
					xhr.onreadystatechange = function () {
						if (xhr.readyState === 4 && xhr.status === 200) {
							h.stored = true;
							return true
						} else if (xhr.readyState === 4 && xhr.status !== 200) {
							window.alert('Something went wrong submitting previous doc!');
							return false
						}
					};
				}
				return true
			},

			submit: function() {
				var xhr = new XMLHttpRequest();
				xhr.open('POST', '/assess');
				xhr.setRequestHeader('Content-Type', 'application/json');
				var req = [];
				for (var i = 0; i < this.hits.length; i++) {
					var h = this.hits[i];
					if (!h.stored && (h.relevance != undefined || h.relevance != '')) {
						req.push({'id': parseInt(h.id), 'relevance': h.relevance})
					}
				}
				xhr.send(JSON.stringify({'id': topicId, 'assessments': req}));
				xhr.onreadystatechange = function () {
					// console.log(xhr.readyState, xhr.status);
					if (xhr.readyState === 4 && xhr.status === 200) {
						window.location = '/'
					} else if (xhr.readyState === 4 && xhr.status !== 200) {
						window.alert('Something went wrong!')
					}
				};
			},

			getSelection: function() {
				var vm = this

				var el = document.getElementById('j-txt');
				var sel = window.getSelection();
				var r = sel.getRangeAt(0);
				console.log(sel);
				console.log(r)

				// This is probably not very efficient. It works by finding the
				// position of the start of the text within the html, then
				// adding the offset for both start and end container to get the
				// absolute index positions.
				var sContainerText = r.startContainer.textContent;
				var eContainerText = r.endContainer.textContent;

				var nodes = [r.startContainer.textContent, r.endContainer.textContent];
				var ind = [];
				var pos = [];


				for (var i = 0; i < 2; i++) {
					var txt = nodes[i];
					if (nodes[i].includes("&")) {
						txt = nodes[i].replace(/&/g, '&amp;');
					}
					ind.push(vm.doc.html.indexOf(txt));
					if (i == 0) {
						pos.push(ind[i] + r.startOffset);
					} else {
						pos.push(ind[i] + r.endOffset);
					}
				}

				if (ind[0] >= 0 && ind[1] >= 0) {
					// var text = vm.doc.html.substring(pos[0], pos[1]);
					var tag = {
						'topic_id': topicId,
						'doc_id': parseInt(vm.doc.id),
						'start': pos[0],
						'end': pos[1],
						'start_offset': r.startOffset,
						'end_offset': r.endOffset,
						'start_container': nodes[0],
						'end_container': nodes[1],
						'start_id': parseInt(r.startContainer.parentNode.id.replace('j-','')),
						'end_id': parseInt(r.endContainer.parentNode.id.replace('j-','')),
					}

					var xhr = new XMLHttpRequest();
					xhr.open('POST', '/tag');
					xhr.setRequestHeader('Content-Type', 'application/json');
					xhr.send(JSON.stringify(tag));
					xhr.onreadystatechange = function () {
						if (xhr.readyState === 4 && xhr.status !== 200) {
							window.alert('Something went wrong submitting the tag with positions ' + start + ' ' + end + '. Please let me know.')
						} else if (xhr.readyState === 4 && xhr.status === 200) {
							var res = JSON.parse(xhr.responseText);
							tag.text = sel.toString();
							tag.tag_id = res.id;
							tag.calc = true
							vm.tags.push(tag)
						}
					};
				} else {
					window.alert('Something went wrong with getting your tag positions. Please keep a note of the page and take a screenshot of your tag, and let me know.')
				}
			},

			deleteTag: function(id) {
				var vm = this
				var xhr = new XMLHttpRequest();
				xhr.open('DELETE', '/tag');
				xhr.setRequestHeader('Content-Type', 'application/json');
				xhr.send(JSON.stringify({'id': id}));
				xhr.onreadystatechange = function () {
					if (xhr.readyState === 4 && xhr.status !== 200) {
						window.alert('Something went wrong deleting the tag. Please let me know.')
					} else if (xhr.readyState === 4 && xhr.status === 200) {
						var ind = vm.tags.findIndex(i => i.id === id);
						vm.tags.splice(ind);
					}
				};
			},

			searchTopic: function() {
				var vm = this;
				var ids = [];
				for (var i = 0; i < this.numHits; i++) {
					ids.push(this.hits[i].id);
				}
				if (vm.query != "") {
					vm.queries.push(vm.query);
					var xhr = new XMLHttpRequest();
					xhr.open('POST', '/search');
					xhr.setRequestHeader('Content-Type', 'application/json');
					xhr.send(JSON.stringify({
						'query': vm.query,
						'topic': topicId,
						'fields': ['id', 'case_name'],
						'ids': ids,
					}));
					console.log(xhr);

					xhr.onreadystatechange = function () {
						console.log(xhr.readyState, xhr.status);
						if (xhr.readyState === 4 && xhr.status === 200) {
							var sres = JSON.parse(xhr.responseText);
							for (var i = 0; i < sres.length; i++) {
								vm.hits.push(sres[i]);
							}
						} else if (xhr.readyState === 4 && xhr.status !== 200) {
							window.alert('Something went wrong with your search. Please let me know.')
						}
					};
				}
				return false;
			}
		},

		watch : {
			currentDoc: function() {
				this.assess();
				this.getDoc();
				this.getTags();
			},

			tags : function() {
				var vm = this
				console.log(vm.tags)
				console.log(vm.tags.length)
				for (var i = 0; i < vm.tags.length; i++) {
					var tag = vm.tags[i];
					console.log(tag);
					if (!vm.tags[i].calc) {
						var containers = [];
						for (var j = 0; j < 2; j++) {
							var el, cont;
							if (j == 0) {
								el = document.getElementById("j-"+tag.start_id);
								cont = tag.start_container;
							} else {
								el = document.getElementById("j-"+tag.end_id);
								cont = tag.end_container;
							}
							for (var k = 0; k < el.childNodes.length; k++) {
								if ((el.childNodes[k].nodeType == 3) &&
									(el.childNodes[k].textContent == cont)) {
										containers.push(el.childNodes[k])
								}
							}
						}
						console.log(containers);
						var r = document.createRange();
						r.setStart(containers[0], tag.start_offset);
						r.setEnd(containers[1], tag.end_offset);
						console.log(r)
						this.tags[i].text = r.cloneContents().textContent;
						console.log(r.cloneContents().textContent)
						vm.tags[i].calc = true
					}
				}
			}
		},
		created: function() {
			$.get('/data/' + topicId, function (response, status) {
				this.queries = response.Queries;
				this.hits = response.Results;
				this.getDoc();
			}.bind(this), "json");
		}
	});
</script>
{{ end }}
